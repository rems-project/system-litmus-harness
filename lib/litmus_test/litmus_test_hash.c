#include "lib.h"

/**
 * Litmus test hashing
 *
 * We produce a hash for each litmus test, based on its definition,
 * and use that to track which versions of each test the results are from.
 *
 * Either the test is generated by another tool, and its hash included verbatim,
 * or we generate one here.
 *
 * We do the hashing in two phases:
 *  1. We produce a `hash_vector` of the configuration of a litmus test
 *  2. We apply a SHA-1 hash to the vector to obtain the hash digest.
 * The hexdigest is then the hash we insert into the litmus test result.
 *
 * The vector
 * ==========
 *
 * The vector contains the following elements:
 *  - The litmus test name.
 *  - The init_state hash_vector (see below).
 *  - The threads hash_vector (see below).
 *  - The final condition hash_vector (see below).
 *
 * The init_state hash_vector contains:
 *  - The number of init_state s
 *  - The array of init_varstate_t objects.
 *    Where each init_varstate_t is a product
 *      (type as string, value vector)
 *      where the values in the value vector correspond to those in the init_varstate_t union
 *            where enums are replaced by their string representation (see XYZ_to_str functions).
 *
 * The threads are a vector of each thread, where each thread is:
 *  - The thread code (prefixed with length)
 *  - The number of handlers, followed by each handler's code (each prefixed with length)
 *
 * The compiled ASM machine code is placed directly into the buffer and hashed,
 *
 *
 * The final condition is an ASCII rendering of the herdtools-compatible register names
 * e.g. "0:X1=1 /\ 1:X1=2", or "(0:X1=1 /\ 1:X1=2) \/ (0:X1=2 /\ 1:X1=1)" if multiple results.
 *
 *
 * All strings are prefixed with their length, without NUL terminator.
 * Integers are 32-bit big-endian, unless stated otherwise.
 *
 * All elements are packed tightly, in the order they appear.
 */

char* blit_int(char* tgt, u32 val, bool dry) {
  if (dry)
    goto done;

  write_be(tgt, val);

done:
  return tgt + sizeof(u32);
}

char* blit_long(char* tgt, u64 val, bool dry) {
  if (dry)
    goto done;

  write_be64(tgt, val);

done:
  return tgt + sizeof(u64);
}

char* blit(char* tgt, const char* src, u64 len, bool dry) {
  if (dry)
    goto done;

  for (unsigned int i = 0; i < len; i++) {
    tgt[i] = src[i];
  }

done:
  return tgt + len;
}

char* blit_str(char* tgt, const char* s, bool dry) {
  u32 len = (u32)strlen(s);
  tgt = blit_int(tgt, len, dry);
  tgt = blit(tgt, s, len, dry);
  return tgt;
}

#define OPCODE_LITMUS_HINT 0xd5032fff
#define OPCODE_RET 0xd65f03c0

char* __blit_thread_code_hint(char* buf, u32* thread_code, bool dry) {
  u32* start = NULL;
  u64 len = 0;

  /* look for LITMUS_HINT */
  int i = 0;
  for (;; i++) {
    if (thread_code[i] == OPCODE_LITMUS_HINT) {
      /* litmus code starts at next instr */
      i++;
      start = thread_code + i;
      break;
    }
  }

  for (;; i++, len++) {
    if (thread_code[i] == OPCODE_LITMUS_HINT) {
      break;
    }
  }

  buf = blit_int(buf, len, dry);
  buf = blit(buf, (char*)start, len * sizeof(u32), dry);

  return buf;
}

char* __blit_thread_code_nohint(char* buf, u32* thread_code, bool dry) {
  int i = 0;
  for (;; i++) {
    if (thread_code[i] == OPCODE_RET) {
      break;
    }
  }

  buf = blit_int(buf, i + 1, dry);
  buf = blit(buf, (const char*)thread_code, (i + 1) * sizeof(u32), dry);

  return buf;
}

bool __thread_code_has_hint(const litmus_test_t* test, u32* thread_code, const int n, const char* name) {
  if (thread_code == NULL)
    return true;

  /* sanity: code fits in one page, if spills over, then complain malformed. */
  for (int i = 0; i < 1024; i++) {
    u32 instr = thread_code[i];
    if (instr == OPCODE_LITMUS_HINT)
      return true;
    else if (instr == OPCODE_RET)
      return false;
  }

  fail("Hashing test '%s' failed: Thread %d %s had malformed code.\n", test->name, n, name);
}

char* blit_thread_code(char* buf, const litmus_test_t* test, u32* thread_code, const int n, const char* name, bool dry) {
  if (thread_code == NULL)
    return blit_int(buf, 0, dry);

  if (__thread_code_has_hint(test, thread_code, n, name))
    return __blit_thread_code_hint(buf, thread_code, dry);
  else
    return __blit_thread_code_nohint(buf, thread_code, dry);
}

char* blit_thread_handlers(char* buf, const litmus_test_t* test, int t, bool dry) {
  if (!test->thread_sync_handlers)
    return blit_int(buf, 0, dry);

  buf = blit_int(buf, 2, dry);
  buf = blit_thread_code(buf, test, test->thread_sync_handlers[t][0], t, "EL0 handler", dry);
  buf = blit_thread_code(buf, test, test->thread_sync_handlers[t][1], t, "EL1 handler", dry);
  return buf;
}

char* blit_thread(char* buf, const litmus_test_t* test, int t, bool dry) {
  buf = blit_thread_code(buf, test, (u32*)test->threads[t], t, "code", dry);
  buf = blit_thread_handlers(buf, test, t, dry);
  return buf;
}

char* blit_varstate(char* buf, init_varstate_t* st, bool dry) {
  buf = blit_str(buf, st->varname, dry);
  buf = blit_str(buf, init_type_to_str(st->type), dry);
  switch (st->type) {
  case TYPE_HEAP:
  case TYPE_PTE:
  case TYPE_MAIR:
  case TYPE_FIX:
    buf = blit_long(buf, st->value, dry);
    break;

  case TYPE_ALIAS:
    buf = blit_str(buf, st->aliasname, dry);
    break;

  case TYPE_ATTRS:
    buf = blit_str(buf, prot_type_to_str(st->prot_type), dry);
    buf = blit_long(buf, st->attr_value, dry);
    break;

  case TYPE_REGION_PIN:
    buf = blit_str(buf, st->pinned_var_name, dry);
    buf = blit_str(buf, pin_level_to_str(st->pinned_level), dry);
    break;

  case TYPE_REGION_OFFSET:
    buf = blit_str(buf, st->offset_var_name, dry);
    buf = blit_str(buf, rel_offset_to_str(st->offset_level), dry);
    break;

  case TYPE_REGION_OWN:
    buf = blit_str(buf, own_level_to_str(st->ownership_level), dry);
    break;

  default:
    unreachable();
  }
  return buf;
}

char* blit_init_state(char* buf, const litmus_test_t* test, bool dry) {
  buf = blit_int(buf, test->no_init_states, dry);

  for (int i = 0; i < test->no_init_states; i++) {
    init_varstate_t* st = test->init_states[i];
    buf = blit_varstate(buf, st, dry);
  }

  return buf;
}

char* blit_threads(char* buf, const litmus_test_t* test, bool dry) {
  buf = blit_int(buf, test->no_threads, dry);
  for (int i = 0; i < test->no_threads; i++) {
    buf = blit_thread(buf, test, i, dry);
  }
  return buf;
}

char* blit_final_cond(char* buf, const litmus_test_t* test, bool dry) {
  char final_cond[1024];
  STREAM* t = NEW_BUFFER(final_cond, 1024);

#define SPRINTF_RESULT(RESULT)                          \
  for (int i = 0; i < test->no_regs; i++) {             \
    if (i > 0)                                          \
      sprintf(t, " /\\ ");                              \
    sprint_reg(t, test->reg_names[i], STYLE_HERDTOOLS); \
    sprintf(t, "=%ld", (RESULT)[i]);                    \
  }

  if (test->no_interesting_results) {
    for (int r = 0; r < test->no_interesting_results; r++) {
      if (r > 0)
        sprintf(t, " \\/ ");

      if (test->no_interesting_results > 1)
        sprintf(t, "(");
      SPRINTF_RESULT(test->interesting_results[r]);
      if (test->no_interesting_results > 1)
        sprintf(t, ")");
    }
  } else {
    SPRINTF_RESULT(test->interesting_result);
  }

  buf = blit_str(buf, final_cond, dry);
  return buf;
}

void __warn_on_bad_hash(const litmus_test_t* test) {
  for (int i = 0; i < test->no_threads; i++) {
    if (!__thread_code_has_hint(test, (u32*)test->threads[i], i, "code")) {
      verbose(
        "warning: no LITMUS_START_ASM/LITMUS_END_ASM in Thread %d"
        ", reverting to unstable hash.\n",
        i
      );
    }

    if (!test->thread_sync_handlers)
      continue;

    for (int h = 0; h < 2; h++) {
      if (!__thread_code_has_hint(test, (u32*)test->thread_sync_handlers[i][h], i, "handler")) {
        verbose(
          "warning: no LITMUS_START_ASM/LITMUS_END_ASM in Thread %d sync handler #%d"
          ", reverting to unstable hash.\n",
          i,
          h
        );
      }
    }
  }
}

char* blit_test(char* buf, const litmus_test_t* test, bool dry) {
  buf = blit_str(buf, test->name, dry);
  buf = blit_init_state(buf, test, dry);
  buf = blit_threads(buf, test, dry);
  buf = blit_final_cond(buf, test, dry);
  return buf;
}

digest litmus_test_hash(const litmus_test_t* test) {
  digest r;

  /* give a warning if the hash computation will be unstable */
  __warn_on_bad_hash(test);

  /* dry-run to calculate size */
  u64 size = (u64)blit_test(NULL, test, true);

  /* now do it for real */
  char* buf = ALLOC_SIZED(size);
  blit_test(buf, test, false);
  r = hash_sha1(buf, size);

  FREE(buf);
  return r;
}