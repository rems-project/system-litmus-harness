#!/usr/bin/env python
""" ./read_esr.py
reads an ESR_EL1 value from argv and parses it into something human readable

We want an external tool for debugging the binary
where the binary itself may not be able to output meaningful messages


Example Usage:
    $ ./utilities/read_esr.py 0x2000000
    ESR_EL1 = 0b00000000000000000000000000000000|000000|1|0000000000000000000000000
                            RES0                   EC   IL          ISS
    EC: <Unknown reason.>


Example Usage:
    $ ./utilities/read_esr.py 0x8600000F
    ESR_EL1 = 0b00000000000000000000000000000000|100001|1|0000000000000000000001111
                            RES0                   EC   IL          ISS
    EC: <Instruction Abort taken without a change in Exception level.
        Used for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors.
        Not used for debug related exceptions.>

    ISS: 0b0000000000000000000001111:
    [FnV] 0 <FAR is Valid.>
    [EA] 0 <Not an External Abort.>
    [IFSC] 001111 <Permission fault, level 3.>


Example Usage:
    $ ./utilities/read_esr.py 0x96000005
    ESR_EL1 = 0b00000000000000000000000000000000|100101|1|0000000000000000000000101
                            RES0                   EC   IL          ISS
    EC: <Data Abort taken without a change in Exception level.
        Used for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors.
        Not used for debug related exceptions.>

    ISS: 0b0000000000000000000000101:
    [ISV] 0 <ISS[23:14] are RES0.>
    [FnV] 0 <FAR is Valid.>
    [EA] 0 <Not an External Abort.>
    [CM] 0 <The Data Abort was not generated by the execution of a cache maintenance instruction.>
    [WnR] 0 <Abort caused by an instruction reading from a memory location.>
    [DFSC] 000101 <Translation fault, level 1.>
"""

import sys
import textwrap
from utils import bit, bitmask, bitslice, wrap, integer, human_number

esr = sys.argv[1].strip(": ")
esr = integer(esr)

ec_descs = {
    0b000000: "Unknown reason.",
    0b000001: "Trapped WFI or WFE instruction execution.\nConditional WFE and WFI instructions that fail their condition code check do not cause an exception.",
    0b000011: "When AArch32 is supported at any Exception level\nTrapped MCR or MRC access with (coproc==0b1111) that is not reported using EC 0b000000.",
    0b000100: "When AArch32 is supported at any Exception level\nTrapped MCRR or MRRC access with (coproc==0b1111) that is not reported using EC 0b000000.",
    0b000101: "When AArch32 is supported at any Exception level\nTrapped MCR or MRC access with (coproc==0b1110).",
    0b000110: "When AArch32 is supported at any Exception level\nTrapped LDC or STC access.\nThe only architected uses of these instruction are:\n• An STC to write data to memory from DBGDTRRXint.\n• An LDC to read data from memory to DBGDTRTXint.",
    0b000111: "Access to SVE, Advanced SIMD, or floating-point functionality trapped by CPACR_EL1.FPEN, CPTR_EL2.FPEN, CPTR_EL2.TFP, or CPTR_EL3.TFP control.\nExcludes exceptions resulting from CPACR_EL1 when the value of HCR_EL2.TGE is 1, or because SVE or Advanced SIMD and floating-point are not implemented. These are reported with EC value 0b000000 as described in The EC used to report an exception routed to EL2 because HCR_EL2.TGE is 1 on page D1-2347.",
    0b001100: "When AArch32 is supported at any Exception level\nTrapped MRRC access with (coproc==0b1110).",
    0b001101: "When ARMv8.5-BTI is implemented\nBranch Target Exception.",
    0b001110: "Illegal Execution state.\nalignment fault.",
    0b010001: "When AArch32 is supported at any Exception level\nSVC instruction execution in AArch32 state.\nThis is reported in ESR_EL2 only when the exception is generated because the value of\nHCR_EL2.TGE is 1.",
    0b010101: "When AArch64 is supported at any Exception level\nSVC instruction execution in AArch64 state.",
    0b011000: "When AArch64 is supported at any Exception level\nTrapped MSR, MRS or System instruction execution in AArch64 state, that is not reported using EC 0b000000, 0b000001 or 0b000111.\nThis includes all instructions that cause exceptions that are part of the encoding space defined in System instruction class encoding overview on page C5-377, except for those exceptions reported using EC values 0b000000, 0b000001, or 0b000111.",
    0b011001: "When SVE is implemented\nAccess to SVE functionality trapped as a result of CPACR_EL1.ZEN, CPTR_EL2.ZEN, CPTR_EL2.TZ, or CPTR_EL3.EZ, that is not reported using EC 0b000000.",
    0b011100: "When ARMv8.3-FPAC is implemented\nException from a Pointer Authentication instruction authentication failure See ISS encoding for an exception from a Pointer Authentication instruction authentication failure.",
    0b100000: "Instruction Abort from a lower Exception level.\nUsed for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.",
    0b100001: "Instruction Abort taken without a change in Exception level.\nUsed for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.",
    0b100010: "PC alignment fault exception.",
    0b100100: "Data Abort from a lower Exception level.\nUsed for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.",
    0b100101: "Data Abort taken without a change in Exception level.\nUsed for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.",
    0b100110: "SP alignment fault exception.",
    0b101000: "When AArch32 is supported at any Exception level\nTrapped floating-point exception taken from AArch32 state.\nThis EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is IMPLEMENTATION DEFINED.",
    0b101100: "When AArch64 is supported at any Exception level\nTrapped floating-point exception taken from AArch64 state.\nThis EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is IMPLEMENTATION DEFINED.",
    0b101111: "SError interrupt.",
    0b110000: "Breakpoint exception from a lower Exception level.",
    0b110001: "Breakpoint exception taken without a change in Exception level.",
    0b110010: "Software Step exception from a lower Exception level.",
    0b110011: "Software Step exception taken without a change in Exception level. See ISS encoding for an exception from a Software Step exception.",
    0b110100: "Watchpoint exception from a lower Exception level.",
    0b110101: "Watchpoint exception taken without a change in Exception level.",
    0b111000: "When AArch32 is supported at any Exception level\nBKPT instruction execution in AArch32 state.",
    0b111100: "When AArch64 is supported at any Exception level\nBRK instruction execution in AArch64 state.\nThis is reported in ESR_EL3 only if a BRK instruction is executed.",
}

dabt_fnv = ("FnV", {0: "FAR is Valid", 1: "FAR is not Valid"})
dabt_ea = (
    "EA",
    {0: "Not an External Abort", 1: "IMPLEMENTATION DEFINED External Abort"},
)
dabt_cm = (
    "CM",
    {
        0: "The Data Abort was not generated by the execution of a cache maintenance instruction",
        1: "The Data Abort was generated by either the execution of a cache maintenance instruction or by a synchronous fault on the execution of an address translation instruction. The DC ZVA instruction is not classified as a cache maintenance instruction, and therefore its execution cannot cause this field to be set to 1.",
    },
)

dabt_wnr = (
    "WnR",
    {
        0: "Abort caused by an instruction reading from a memory location.",
        1: "Abort caused by an instruction writing to a memory location.",
    },
)

dabt_fields = {
    24: ("ISV", {0: "ISS[23:14] are RES0", 1: "ISS is valid"}),
    (23, 22): (
        "SAS",
        {0b00: "Byte", 0b01: "Halfword", 0b10: "Word", 0b11: "Doubleword"},
        (24, 1),  #  only valid if ISV==1
    ),
    (20, 16): (
        "SRT",
        "Syndrome Register Transfer. When ISV is 1, the register number of the Rt operand of the faulting instruction.",
        (24, 1),  #  only valid if ISV==1
    ),
    15: (
        "SF",
        {
            0: "Instruction loads/stores a 32-bit wide register.",
            1: "Instruction loads/stores a 64-bit wide register.",
        },
        (24, 1),  #  only valid if ISV==1
    ),
    (12, 11): (
        "SET",
        {
            0b00: "Recoverable error (UER).",
            0b10: "Uncontainable error (UC).",
            0b11: "Restartable error (UEO) or Corrected error (CE).",
        },
        (24, 1),  #  only valid if ISV==1
    ),
    10: dabt_fnv,
    9: dabt_ea,
    8: dabt_cm,
    6: dabt_wnr,
    (5, 0): (
        "DFSC",
        {
            0b000000: "Address size fault, level 0 of translation or translation table base register",
            0b000001: "Address size fault, level 1",
            0b000010: "Address size fault, level 2",
            0b000011: "Address size fault, level 3",
            0b000100: "Translation fault, level 0",
            0b000101: "Translation fault, level 1",
            0b000110: "Translation fault, level 2",
            0b000111: "Translation fault, level 3",
            0b001001: "Access flag fault, level 1",
            0b001010: "Access flag fault, level 2",
            0b001011: "Access flag fault, level 3",
            0b001101: "Permission fault, level 1",
            0b001110: "Permission fault, level 2",
            0b001111: "Permission fault, level 3",
            0b010000: "Synchronous External abort, not on translation table walk or hardware update of translation table",
            0b010001: "When ARMv85-MemTag is implemented Synchronous Tag Check Fault",
            0b010100: "Synchronous External abort, on translation table walk or hardware update of translation\ntable, level 0",
            0b010101: "Synchronous External abort, on translation table walk or hardware update of translation table, level 1",
            0b010110: "Synchronous External abort, on translation table walk or hardware update of translation table, level 2",
            0b010111: "Synchronous External abort, on translation table walk or hardware update of translation table, level 3",
            0b011000: "When RAS is not implemented Synchronous parity or ECC error on memory access, not on translation table walk",
            0b011100: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0",
            0b011101: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1",
            0b011110: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2",
            0b011111: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3",
            0b100001: "Alignment fault",
            0b110000: "TLB conflict abort",
            0b110001: "When ARMv81-TTHM is implemented Unsupported atomic hardware update fault",
            0b110100: "IMPLEMENTATION DEFINED fault (Lockdown)",
            0b110101: "IMPLEMENTATION DEFINED fault (Unsupported Exclusive or Atomic access)",
        },
    ),
}

svc_imm = (
    "imm16",
    "For an HVC instruction, and for an A64 SVC instruction, this is the value of the imm16 field of the issued instruction.",
)
svc_fields = {
    (15, 0): svc_imm,
}

iabt_fields = {
    10: dabt_fnv,
    9: dabt_ea,
    (5, 0): (
        "IFSC",
        {
            0b000000: "Address size fault, level 0 of translation or translation table base register.",
            0b000001: "Address size fault, level 1.",
            0b000010: "Address size fault, level 2.",
            0b000011: "Address size fault, level 3.",
            0b000100: "Translation fault, level 0.",
            0b000101: "Translation fault, level 1.",
            0b000110: "Translation fault, level 2.",
            0b000111: "Translation fault, level 3.",
            0b001001: "Access flag fault, level 1.",
            0b001010: "Access flag fault, level 2.",
            0b001011: "Access flag fault, level 3.",
            0b001101: "Permission fault, level 1.",
            0b001110: "Permission fault, level 2.",
            0b001111: "Permission fault, level 3.",
            0b010000: "Synchronous External abort, not on translation table walk or hardware update of translation table.",
            0b010100: "Synchronous External abort, on translation table walk or hardware update of translation table, level 0.",
            0b010101: "Synchronous External abort, on translation table walk or hardware update of translation table, level 1.",
            0b010110: "Synchronous External abort, on translation table walk or hardware update of translation table, level 2.",
            0b010111: "Synchronous External abort, on translation table walk or hardware update of translation table, level 3.",
            0b011000: "When RAS is not implemented Synchronous parity or ECC error on memory access, not on translation table walk.",
            0b011100: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.",
            0b011101: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.",
            0b011110: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.",
            0b011111: "When RAS is not implemented Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.",
            0b110000: "TLB conflict abort.",
        },
    ),
}

msr_fields = {
    (21, 20): "Op0",
    (19, 17): "Op2",
    (16, 14): "Op1",
    (13, 10): "CRn",
    (9, 5): "Rt",
    (4, 1): "CRm",
    0: (
        "Direction",
        {
            0: "Write access, including MSR instructions.",
            1: "Read access, including MRS instructions.",
        },
    ),
}

iss_fields_structs = {
    0b010001: svc_fields,
    0b010101: svc_fields,
    0b011000: msr_fields,
    0b100000: iabt_fields,
    0b100001: iabt_fields,
    0b100100: dabt_fields,
    0b100101: dabt_fields,
}

ec = bitslice(esr, 31, 26)
il = bit(esr, 25)
iss = bitslice(esr, 24, 0)

print(f"ESR_EL1 = 0b{0:>032b}|{ec:>06b}|{il:>1b}|{iss:>025b}")
print("                           RES0                EC   IL          ISS   ")

ec_desc = wrap(ec_descs[ec], prefix="EC: <")
print(f"EC: <{ec_desc}>")

iss_fields = iss_fields_structs.get(ec)
if iss_fields is not None:
    print()
    print(f"ISS: {human_number(iss, 25)} :")
    for f, v in iss_fields.items():
        if isinstance(f, int):
            vbit = bit(iss, f)
            bit_len = 1
        else:
            vbit = bitslice(iss, *f)
            bit_len = f[0] - f[1] + 1

        if isinstance(v, tuple):
            fname, field, *req = v

            # sometimes a field is only valid
            #  if another field has a particular value
            if req:
                skip = False
                for r in req:
                    reqidx, reqval = r
                    if bit(iss, reqidx) != reqval:
                        skip = True
                        break
                if skip:
                    continue
        else:
            fname = v
            field = None

        prefix = f" [{fname}] {human_number(vbit, bit_len)}"
        print(prefix, end="")
        if isinstance(field, str):
            print(f" <{field}>")
        elif isinstance(field, dict):
            field_desc = field[vbit]
            print(f" <{wrap(field_desc,prefix+' <')}>")
        else:
            print()  # no field comment required
